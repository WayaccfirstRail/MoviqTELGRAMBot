# ---------------------------------------------------------------------------
# Ticketing System
# ---------------------------------------------------------------------------
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Dict, List, Any

# This list will hold all tickets.  Each ticket is a dict with:
# id, user_id, user_link, category, message, timestamp, closed (bool)
tickets: List[Dict[str, Any]] = load_from_database('tickets', [])

# Map user_id -> category when waiting for the user to type their ticket message
waiting_for_ticket: Dict[int, str] = {}


async def ticket_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Allow a user to create a ticket by choosing a category."""
    user_id = update.effective_user.id
    # Respect existing ban/block lists
    if user_id in banned_users:
        return
    if user_id in blocked_users:
        await update.message.reply_text(
            "Ù„Ù‚Ø¯ ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©."
        )
        return
    # Show category options
    keyboard = [
        [InlineKeyboardButton("ğŸ’¡ Ø§Ù‚ØªØ±Ø§Ø­", callback_data="ticket_suggestion")],
        [InlineKeyboardButton("âš ï¸ Ø¨Ù„Ø§Øº", callback_data="ticket_report")],
        [InlineKeyboardButton("ğŸ“© ØªØ­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ù…Ø§Ù„Ùƒ", callback_data="ticket_owner")],
    ]
    await update.message.reply_text(
        "Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def handle_ticket_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Capture the user's message when they are creating a ticket."""
    user_id = update.effective_user.id
    # Only handle this message if we're expecting a ticket from the user
    if user_id in waiting_for_ticket:
        # Pop the category to avoid processing extra messages
        category = waiting_for_ticket.pop(user_id)
        message_text = update.message.text.strip()
        # Create a unique ticket ID using the current timestamp (milliseconds)
        now = datetime.now(ZoneInfo("Africa/Cairo"))
        ticket_id = str(int(now.timestamp() * 1000))
        # Build a clickable link for the user
        user_link = f"[{update.effective_user.first_name}](tg://user?id={user_id})"
        # Create the ticket record
        ticket = {
            "id": ticket_id,
            "user_id": user_id,
            "user_link": user_link,
            "category": category,
            "message": message_text,
            "timestamp": now.strftime("%Y-%m-%d %H:%M"),
            "closed": False,
        }
        tickets.append(ticket)
        # Persist tickets
        save_to_database('tickets', tickets)
        # Confirm to the user
        await update.message.reply_text(
            "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØªØ°ÙƒØ±ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­! Ø³Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ù‹Ø§.",
            parse_mode='Markdown'
        )
        # Forward to admins (owners).  Each admin receives a button to close the ticket.
        text = (
            "ğŸŸï¸ **ØªØ°ÙƒØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©**\n\n"
            f"**Ø§Ù„Ù†ÙˆØ¹:** {category}\n"
            f"**Ø§Ù„Ù…Ø±Ø³Ù„:** {user_link}\n"
            f"**Ø§Ù„ÙˆÙ‚Øª:** {ticket['timestamp']}\n"
            f"**Ø§Ù„Ø±Ø³Ø§Ù„Ø©:**\n{message_text}"
        )
        reply_markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ”’ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©", callback_data=f"close_ticket_{ticket_id}")]
        ])
        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=text,
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
            except Exception:
                # In case sending fails, we ignore the error
                pass
    else:
        # If this message isn't part of a ticket, fall back to existing admin handler
        await handle_admin_input(update, context)


async def admin_view_tickets(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin command: list all tickets with their status."""
    user_id = update.effective_user.id
    if not user_is_admin(user_id):
        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙÙ‚Ø·.")
        return
    if not tickets:
        await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ°Ø§ÙƒØ± Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return
    lines = []
    for idx, t in enumerate(tickets, 1):
        status = "âœ… Ù…ØºÙ„Ù‚Ø©" if t.get("closed") else "ğŸ•’ Ù…ÙØªÙˆØ­Ø©"
        lines.append(
            f"{idx}. {t['user_link']} - {t['category']} - {t['timestamp']} - {status}"
        )
    msg = "ğŸ“„ **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ°Ø§ÙƒØ±**\n\n" + "\n".join(lines)
    keyboard = [
        [InlineKeyboardButton("ğŸ§¹ Ø­Ø°Ù Ø§Ù„ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…ØºÙ„Ù‚Ø©", callback_data="clear_closed_tickets")]
    ]
    await update.message.reply_text(
        msg,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def admin_view_ticket_users(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin command: show unique users who submitted tickets."""
    user_id = update.effective_user.id
    if not user_is_admin(user_id):
        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙÙ‚Ø·.")
        return
    if not tickets:
        await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ°Ø§ÙƒØ± Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return
    unique_links: List[str] = []
    seen_ids = set()
    for t in tickets:
        if t['user_id'] not in seen_ids:
            seen_ids.add(t['user_id'])
            unique_links.append(t['user_link'])
    msg = "ğŸ‘¥ **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø°ÙŠÙ† Ø£Ø±Ø³Ù„ÙˆØ§ ØªØ°Ø§ÙƒØ±:**\n\n" + "\n".join(
        [f"{idx + 1}. {link}" for idx, link in enumerate(unique_links)]
    )
    await update.message.reply_text(msg, parse_mode='Markdown')


async def admin_pending_tickets(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin command: count how many tickets are still open."""
    user_id = update.effective_user.id
    if not user_is_admin(user_id):
        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙÙ‚Ø·.")
        return
    open_count = sum(1 for t in tickets if not t.get("closed"))
    if open_count == 0:
        msg = "âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ°Ø§ÙƒØ± Ø¨Ø­Ø§Ø¬Ø© Ø¥Ù„Ù‰ Ø±Ø¯."
    else:
        msg = f"ğŸ“¬ ÙŠÙˆØ¬Ø¯ {open_count} ØªØ°ÙƒØ±Ø© Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø±Ø¯."
    await update.message.reply_text(msg)


async def handle_ticket_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle inline button callbacks for ticketing:
    - Choosing ticket category
    - Closing a ticket
    - Clearing all closed tickets
    """
    query = update.callback_query
    await query.answer()
    data = query.data
    user_id = query.from_user.id
    # User chooses the type of ticket
    if data.startswith("ticket_"):
        category = data.split("_", 1)[1]
        waiting_for_ticket[user_id] = category
        await query.message.reply_text("âœ‰ï¸ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù†:")
    # Admin clicks "close ticket"
    elif data.startswith("close_ticket_"):
        ticket_id = data[len("close_ticket_"):]
        target_user_id = None
        for t in tickets:
            if t["id"] == ticket_id and not t.get("closed"):
                t["closed"] = True
                target_user_id = t["user_id"]
                break
        save_to_database('tickets', tickets)
        # Edit the original admin message or send a new one confirming closure
        try:
            await query.edit_message_text("ğŸ”’ ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©.", parse_mode='Markdown')
        except Exception:
            await query.message.reply_text("ğŸ”’ ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©.", parse_mode='Markdown')
        # Notify the original user (if available)
        if target_user_id:
            try:
                await context.bot.send_message(
                    chat_id=target_user_id,
                    text="âœ… ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØªØ°ÙƒØ±ØªÙƒ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„.",
                    parse_mode='Markdown'
                )
            except Exception:
                pass
    # Admin clicks "clear closed tickets"
    elif data == "clear_closed_tickets":
        # Filter out closed tickets
        tickets[:] = [t for t in tickets if not t.get("closed")]
        save_to_database('tickets', tickets)
        await query.message.reply_text("ğŸ§¹ ØªÙ… Ø­Ø°Ù Ø§Ù„ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…ØºÙ„Ù‚Ø©.")


# ---------------------------------------------------------------------------
# Handler registration (add these lines in main() during setup)
# ---------------------------------------------------------------------------

# Command to start a new ticket
# application.add_handler(CommandHandler("ticket", ticket_command))

# Admin commands for ticket management
# application.add_handler(CommandHandler("tickets", admin_view_tickets))
# application.add_handler(CommandHandler("ticket_users", admin_view_ticket_users))
# application.add_handler(CommandHandler("pending_tickets", admin_pending_tickets))

# Ticket-related callback queries (category selection, closing, clearing)
# application.add_handler(CallbackQueryHandler(handle_ticket_callback, pattern="^(ticket_|close_ticket_|clear_closed_tickets)"))

# Message handler for capturing ticket messages.
# Place this handler **before** handle_admin_input so it intercepts ticket messages first.
# application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_ticket_input), group=1)
